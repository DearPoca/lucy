<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>my live</title>
    <div id="username" data-value={{ .username }}></div>
    <script src="/assets/js/common_links.js"></script>
    <script src="/assets/js/third_party/srs.sdk.js"></script>
    <script src="/assets/js/third_party/flv.min.js"></script>
    <link rel="stylesheet" href="/assets/css/table.css">
    <link rel="stylesheet" href="/assets/css/video-play-pages.css">
    <style>
        button {
            height: 40px;
            padding: 10px 30px 10px 30px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <br><br>
    <center id="center-content">
        <button onclick='startLiveWithWebrtc("screen")'>screen sharing</button>
        <button onclick='startLiveWithWebrtc("camera")'>camera capture</button>
        <button onclick='getStreamingAddr()'>streaming addr</button>
    </center>
    <br><br>
    <center>
        <div id="video-container">
        </div>
    </center>
</body>
<script>
    function getStreamingAddr() {
        let rtmpUrl = {{ .rtmp_url }};
        let flvUrl = {{ .flv_url }};

        let centerContent = document.getElementById("center-content");
        while (centerContent.firstChild) {
            centerContent.firstChild.remove()
        }

        let p = document.createElement("p");
        p.textContent = `streaming addr: `

        let textArea = document.createElement("textarea");
        centerContent.appendChild(textArea);
        textArea.textContent = rtmpUrl
        textArea.id = "rtmp-url"
        textArea.cols = 60
        textArea.readOnly = true

        let buttonCopy = document.createElement("button");
        buttonCopy.textContent = "copy"
        buttonCopy.onclick = function () {
            textArea.select();
            document.execCommand("Copy");
            alert("ok!");
        }

        let buttonWatch = document.createElement("button");
        buttonWatch.textContent = "watch"
        buttonWatch.onclick = function () {
            if (flvjs.isSupported()) {
                let old = document.getElementById("flv_player");
                if (old) {
                    old.remove()
                }
                let videoElement = document.createElement('video')
                centerContent.appendChild(videoElement);
                videoElement.id = "flv_player"
                videoElement.autoplay = true
                videoElement.controls = true
                videoElement.preload = "auto"
                videoElement.muted = true
                let flvPlayer = flvjs.createPlayer({
                    type: 'flv',
                    url: flvUrl,
                    isLive: true
                })
                flvPlayer.attachMediaElement(videoElement)
                flvPlayer.load()
                flvPlayer.play()
            }
        }

        centerContent.appendChild(p);
        centerContent.appendChild(textArea);
        centerContent.appendChild(document.createElement("br"));
        centerContent.appendChild(document.createElement("br"));
        centerContent.appendChild(buttonCopy);
        centerContent.appendChild(buttonWatch);
    }

    function startLiveWithWebrtc(videoSrc) {
        constraints = {
            audio: true,
            video: {
                width: {ideal: 1280, max: 1920}
            }
        };

        let v_container = document.getElementById("video-container");
        let rtc_media_player = document.createElement("video");
        rtc_media_player.id = "rtc-media-player"
        rtc_media_player.autoplay = "autoplay"
        rtc_media_player.controls = "controls"
        v_container.appendChild(rtc_media_player);

        let sdk = new SrsRtcPublisherAsync(constraints, videoSrc);

        // User should set the stream when publish is done, @see https://webrtc.org/getting-started/media-devices
        // However SRS SDK provides a consist API like https://webrtc.org/getting-started/remote-streams
        // Optional callback, SDK will add track to stream.
        // sdk.ontrack = function (event) { console.log('Got track', event); sdk.stream.addTrack(event.track); };

        // https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs#getting_the_supported_codecs
        sdk.pc.onicegatheringstatechange = function (event) {
            if (sdk.pc.iceGatheringState === "complete") {
                console.log(sdk.pc.getSenders())
            }
        };

        let url = {{ .webrtc_url }};
        sdk.publish(url).then(function (session) {
            console.log(session)
            rtc_media_player.srcObject = sdk.stream
        }).catch(function (reason) {
            // Throw by sdk.
            if (reason instanceof SrsError) {
                if (reason.name === 'HttpsRequiredError') {
                    alert(`WebRTC must be HTTPS or localhost：${reason.name} ${reason.message}`);
                } else {
                    alert(`${reason.name} ${reason.message}`);
                }
            }
            // See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#exceptions
            if (reason instanceof DOMException) {
                if (reason.name === 'NotFoundError') {
                    alert(`can not find devices：getUserMedia ${reason.name} ${reason.message}`);
                } else if (reason.name === 'NotAllowedError') {
                    alert(`devices are not allow：getUserMedia ${reason.name} ${reason.message}`);
                } else if (['AbortError', 'NotAllowedError', 'NotFoundError', 'NotReadableError', 'OverconstrainedError', 'SecurityError', 'TypeError'].includes(reason.name)) {
                    alert(`getUserMedia ${reason.name} ${reason.message}`);
                }
            }

            sdk.close();
            rtc_media_player.hide();
            console.error(reason);
        });
        let centerContent = document.getElementById("center-content");
        centerContent.remove();
    }
</script>
</html>